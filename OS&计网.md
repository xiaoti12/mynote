# 进程、线程、协程

## 进程的状态

两个基本状态：创建、结束

三个运行时状态：运行、就绪、阻塞

这几个状态的转换关系：

![进程五种状态的变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg)

## 进程和线程区别

- 进程是程序在内存中运行的一个实例，是管理资源的基本单位；线程是程序调度的基本单位
- 一个进程可以拥有一个或多个线程
- 进程切换上下文开销更大，需要保存/加载虚拟内存、栈、全局变量、程序计数器等资源；线程共享资源，同一进程的线程切换只需要切换私有数据、寄存器等等
- 进程的资源互相隔；线程共享进程资源，需要处理数据一致性

## 通信与同步

### 进程的通信

- 管道/匿名管道：父子进程或兄弟进程通信
- 有名管道：磁盘文件，先进先出
- 信号：用于通知进程事件
- 消息队列
- 信号量：用于进程同步，控制多进程对共享数据的访问
- 共享内存：让多个进程访问同一块内存空间
- 套接字：利用socket函数来进行通信

> windows下采用Message消息机制和CEvent对象机制

### 线程的通信/同步

- 同进程的共享变量
- 互斥锁：保证公共资源同时被一个线程访问
- 读写锁：可同时读，读写互斥
- 信号量：控制多线程对共享数据的访问

## 协程

用户态的轻量级线程，调度由用户控制，对内核不可见。可以减少上下文切换开销，与线程相比内存消耗更少，并且可以按需求增大。

# 死锁

## 死锁条件

同时满足以下四个条件时，才可能产生死锁：

- 互斥：多个线程不能同时使用一个资源
- 持有等待：某个线程拥有了资源1，不释放的同时请求资源2
- 不可剥夺：线程拥有的资源在使用完前，不能被其他线程获取
- 环路等待：几个线程获取资源的顺序构成了环形链

## 悲观锁和乐观锁

### 悲观锁

认为访问资源时冲突概率较高，因此访问之前需要上锁。包括以下种类：

- 互斥锁：对资源进行独占，一次只能一个线程访问；如果加锁失败后释放CPU
- 自旋锁：同样试图独占资源，加锁失败后开始**忙等待**，持续试图获取锁

### 乐观锁

认为访问资源时冲突概率较低，因此不使用锁。修改完共享资源后验证是否发生冲突，如果已经冲突过则放弃操作。

实际例子：在线文档、**Git**

# I/O多路复用

为了处理高吞吐量的TCP连接，如果为每个连接分配一个进程或线程，会消耗大量资源。此时可以使用I/O多路复用，只使用一个进程来维护多个socket。

## select

将已连接的socket放到**文件描述符（fd）集合**。内核遍历该集合，检查是否有网络事件。

select使用固定长度的集合，并且需要线性扫描。

## poll

与select的监视方式基本一致，不过socket对应的fd放入的是链表，可以实现更大的数量。不过检查网络实现仍然需要遍历。

## epoll

大致的用法流程：

1. 创建`epfd`对象
2. 通过`epoll_ctl`函数将socket添加到`epfd`对象中（内部是红黑树）
3. 调用`epoll_wait`等待数据。当某个socket有事件发生后，通过回调函数将其加入就绪列表

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png)

> 使用红黑树而不是哈希表，是因为大量的socket使哈希表扩容，导致不小开销；而红黑树在扩容和缩容上稳定很多

此外，epoll还有两种事件触发方式：

- 水平触发：默认方式，`epoll_wait`不断触发，直到fd的数据被读完
- 边缘触发：`epoll_wait`只苏醒一次，因此程序要保证一次性读完



# TCP握手和挥手

## 三次握手

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

### 两次握手的问题

1. 避免历史连接

    不使用两次连接的首要原因（RFC里指出）。如果使用两次连接，当客户端前后分别发送两次**不同序号**的SYN包时（中间客户端宕机等情况），第一次先到达后，服务器建立连接、发送数据；而客户端则认为ACK号不符，发送RST，浪费服务器资源。而三次握手，服务端可以确认客户端是ACK包还是RST包

2. 同步序列号

3. 避免资源浪费

    服务器收到多个**相同序号**的SYN时可能会建立重复连接（第一次SYN网络阻塞，客户端重传）

### 四次握手的问题

理论上三次握手就可以建立可靠连接，四次会增加网络开销

### 随机序列号

TCP每次握手前会随机产生初始序列号，原因如下：

- 防止历史报文被下一个连接接受
- 防止伪造相同序列号报文

## 四次挥手

双方都可以主动断开连接，每次主动断开需要FIN和ACK两个数据包。

![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

### TIME_WAIT状态

TIME_WAIT是最开始主动关闭连接的一方所拥有的状态。TIME_WAIT状态至少要持续2个MSL时间，才会关闭连接。

> MSL：报文最大生存时间，报文在网络中存在的最长时间，超过将被丢弃

需要TIME_WAIT状态，以及时间为2MSL的原因：

1. 防止历史连接数据被下一个TCP连接错误接受

    假设在挥手结束前有一个TCP包被网络阻塞，如果不等待，则下次握手后该包到达，可能引发错误。

2. 保证连接正确关闭

    假设第二次接收到FIN包、进入TIME_WAIT状态、发送ACK包后，ACK包快要到达时刚好被丢弃，此时重传FIN包，刚好2个MSL时间。如果没有TIME_WAIT状态，对于重传的FIN包会回复RST包，表示为错误关闭。

# TCP可靠传输

TCP为了保证可靠传输，使用了如下机制：

- 序号和确认号：TCP会通过SEQ和ACK来保证数据的一致性，回复ACK来表示已经接收到该数据包。A->B的ACK为X、SEQ为Y、Len为L，则B->A的ACK为Y+L、SEQ为X，即ACK为期望对方下次发送的SEQ
- 超时重传：如果发送方在定时器的时间内，没收到ACK确认则重传
- 滑动窗口：用于缓存待发送或接收数据，可以互相通知
- 流量控制：接受方会回复自己的剩余窗口大小，发送方得知对方的处理能力，控制发送的速度
- 拥塞控制：慢启动和快速恢复

![快速重传和快速恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)

# HTTP2和HTTP3

## HTTP2特点

1. 头部压缩：使用动静态字典来表示重复字符串；使用Huffman编码压缩数据
2. 二进制帧：用二进制格式，而不是ASCII码来传输数据
3. 并发传输：通过stream ID，在同一条TCP连接上跑多个stream

## HTTP3/QUIC

将HTTP的下层协议从TCP更换为UDP，并在应用层实现了QUIC协议，结合了TCP和UDP的特点

### QUIC协议特点

- 无队头阻塞：复用的stream之间不依赖，小序号包丢失后，不会阻塞后面的报文
- 连接速度：QUIC协议握手减少到1 RTT、TLS升级到1.3减少握手次数
- 连接迁移：不使用四元组来标识连接，而是使用唯一连接ID，这样设备网络变化后，仍可以保留上下文信息

# 其他网络协议

## RPC

RPC和HTTP的区别：

- 服务发现：HTTP需要DNS寻找IP；RPC需要注册中心
- 底层连接：HTTP基于TCP，可以保持长连接；RPC使用连接池，复用连接
- 内容编码：HTTP使用语义编码；RPC采用二进制序列化编码，例如protobuf

## SSE和WebSocket

SSE和websocket都可以用于服务器主动推送数据





