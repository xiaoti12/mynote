# 索引原理

## 创建

mysql可以显式地为列创建索引，语句：`create index INDEXNAME on TABLE COLUMN1(, COLOMUN2...)`

通过使用索引，mysql可以直接定位到查询的行，而无需逐行扫描

## B树和B+树

### B树

B树是平衡二叉树引申而来的，属于多叉树。B树的要点：

- **节点**：为一个列表形式，包含关键字（*图中的数字*）以及指针。关键字递增排列，指针指向子节点。关键字左边指针指向的子树所有值均**小于**关键字，右边指针指向的子树所有值**大于**关键字。
- 子节点数：对于M阶B树，非叶节点的子节点范围为 $[\ \lceil m/2 \rceil,m\ ]$。
- 非叶结点的关键字树为k，则子节点数为k+1

B树的查找 $t$ 过程：

- 通过二分查找，从关键字列表中  $t$ 命中值，或者所属区间，取该区间的指针。
- 通过指针访问子节点，在子节点重复上面操作
- 直到命中节点 $t$、取节点所存放的数据；或者在叶子节点找不到该值

![clip_image002](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png)

### B+树

B+树在B树的基础上，做出了如下改进：

- 只在叶子节点保存数据，非叶子节点只保存关键字。叶子节点会保存所有关键字对应的数据
- 叶子节点的关键字会形成一个有序链表

因此，B+树的查询次数会更加稳定（都需要到叶子节点），B+树相比B树，非叶子节点不存储数据，因此可以存放更多关键字，使得树更矮，减少IO操作。

对于范围查询等遍历操作，B+树可以找到首个叶子节点后，通过链表进行遍历；而B树需要进行树的遍历。

![img](https://ask.qcloudimg.com/http-save/yehe-7619914/qd4miq0erv.png)

## InnoDB

mysql默认使用InnoDB作为引擎。InnoDB会将数据以**页**为单位，大小为16KB。一页可以分为4个块（每个块大小为4KB），这样当读取某个数据时，基于局部性原理，会将数据所在的页载入到内存。在后续通过B+树建立索引时，会以页为单位。

在InnoDB的B+树中，叶子节点通过双向链表连接。

![图片](https://cdn.xiaolincoding.com//mysql/other/dd076212a7637b9032c97a615c39dcd7.png)

# 索引场景

## 主键索引

从物理存储来说，索引可以分为：

- 聚集索引（主键索引、聚簇索引）：对于主键形成的索引
- 二级索引（辅助索引）：自行指定列构建的索引

两种索引均为B+树，聚集索引树叶子节点存放实际数据；二级索引树的叶子节点只存放对应**主键值**

- 如果从聚集索引 / 二级索引的一棵索引树上获取所需数据，则称为**索引覆盖**

- 如果需要去主键树进一步查找，则称为**回表**现象。

创建表时，InnoDB会按如下顺序选择列，生成聚集索引：

- 默认选择主键
- 选择第一个不包含NULL值的列
- 生成隐式自增ID列

## 索引失效

下面情况索引可能会失效：

- 左/左右模糊匹配：like %xx或like %xx%，因为B+树需要进行前缀匹配，因此like xx%仍能使用索引
- 对索引使用函数、表达式、隐式类型转换（可能）
- where中使用or时有一个条件列不是索引列
- 对于联合索引，查询不符合最左匹配

## 其他索引分类

按字段特性分类：

- 主键索引
- 唯一索引：建立在unique字段上的索引
- 普通索引
- 前缀索引：对字符串类型字段的前N个字符创建的索引，可以减少其占用的空间

按字段个数分类：

- 单列索引
- 联合索引：多个字段组合形成的索引，B+树中使用顺序组合字段作为key值进行查找

使用联合索引时，会使用**最左前缀原则**。例如创建(a,b,c)索引时后，只有a、ab、ac、abc可以生效。因为联合字段优先排布最左字段，在**全局有序**的。而只有在左边字段确定的情况下，后面的字段才是有序的（**局部有序**）。

# MYSQL执行语句过程

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:67%;" />

## 连接器

mysql通过TCP协议，在客户端与服务端之间进行连接

## 查询缓存

如果是查询语句，会从缓存中进行查询（k-v形式，k为查询语句，v为结果）

在8.0中缓存已被移除，因为表更新时，该表的查询缓存会被清空，命中率低

## 解析SQL

1. 词法分析
2. 语法分析，如果语法不对则会报错

## 执行SQL

1. 预处理，查询表、字段的存在，展开`*`通配符
2. 优化器，选择索引/全表扫描
3. 执行器，与存储引擎进行交互

# 事务特性

事务由MYSQL引擎提供支持，5.5以前的默认引擎MyISAM不支持，新的InnoDB支持。

事务包含以下特征ACID：

- 原子性：事务的所有操作要么全完成，要么全不完成。通过**undo log**保证
- 一致性：操作前后，满足数据库一致性。通过其他三个特征保证
- 隔离性：多个事务操作相同数据时，不会相互干扰（*重点*）。通过**MVCC/锁机制**保证
- 持久性：事务结束后，对数据修改是永久的。通过**redo log**保证

## undo log

用于撤销回退的日志。在事务提交前，MYSQL会记录更新前的数据到undo log，例如：

- 执行 insert 时，记录主键值，回滚时删除
- 执行 delete 时，记录内容，回滚时插入
- 执行 update 时，记录旧值，回滚时更新

undo log的格式包括：事务ID trx_id、日志链表指针 roll_pointer，具体见MVCC章

## redo log

> 当有一条新的记录时，InnoDB会先更新内存中的缓存池（buffer pool），在适当的时候由后台线程将缓存池中的数据刷新到磁盘

redo log会记录某个数据页的修改操作，当事务提交时，先将redo log固化到磁盘。

写入redo log是追加式的顺序写入，而数据写入数据库是随机写，效率会高很多。

## redo和undo区别

- redo log记录的是事务完成后的状态、更新之后的值
- undo log记录的是事务开始前的状态、更新之前的值
- 事务提交后崩溃，通过redo log恢复事务
- 事务提交前崩溃，通过undo log回滚事务

# 事务的并行与隔离

## 并行事务可能的问题

严重性从高到底

- 脏读：事务B读到了事务A *未提交事务修改的数据* ，如果事务A回滚，则B读到的是过期数据
- 不可重复读：事务读取同一数据时，前后数据不一样
- 幻读：事务查询同一条件的记录数量时，前后数量不一样

## SQL隔离级别

四种隔离级别如下，安全性从低到高，性能效率从高到低：

1. 读未提交：事务未提交时，变更能被看到
    - 可能发生：脏读、不可重复读、幻读
2. 读提交：事务提交后，变更能被看到。会在执行语句前生成read view。
    - 可能发生：不可重复读、幻读
3. 可重复读：事务执行时的数据和刚启动时的数据是一致的，**InnoDB默认隔离级别**。会在事务开启时生成read view。
    - 可能发生：幻读（可以很大程度避免）
4. 串行化：对记录加上读写锁
    - 不会发生并行问题

## MYSQL与幻读

mysql针对幻读现象的解决方法：

对于普通select语句，通过MVCC解决。简单来说，会在事务开始时创建一个数据快照。

针对当前读select for update语句，通过next-key lock（间隙锁+记录锁）解决。此时其他记录无法对next-key lock的范围内修改记录

# 锁

## 锁的类型

- **全局锁**
    - 锁住整个数据库，处于只读状态
    - 适合全库备份
    - 如果引擎支持可重复读，可以备份前开启事务创建read view，这时可以避免锁
- **表锁**
    - 会影响并发性能，避免使用
    - 意向锁：快速判断表里是否有记录被加锁
- **行级锁**

### 行级锁 

InnoDB支持的锁级别，MyISAM引擎不支持。包含以下类型：

- 记录锁：锁住记录，分为共享锁/S锁（读读共享）和独占锁/X锁（读写互斥），也就是说只有加了S锁，可以再加S锁，其他均互斥
- 间隙锁：表示范围内的锁，解决可重复读下幻读问题，可以理解为开开区间的锁
- next-sky锁：记录锁+间隙锁，可以理解为开闭区间的锁

## 加锁过程

普通的select不会加锁，属于快照读。如果想对select语句加锁，需要使用：

```sql
begin; -- 开启事务
select ... lock in share mode; -- 对读取的记录加共享锁(S型锁)
select ... for update; -- 对读取的记录加独占锁(X型锁)
commit; -- 释放锁
```

InnoDB自己实现了行锁，通过next-key锁，锁住记录和间隙。

update、delete、insert等语句会产生锁操作，阻塞其他读写操作。此时如果不是索引查询，就会引起**全表扫描**，会对每个记录加锁，退化成表锁。因此要先用explain语句检查

## explain

explain字段会返回的记录：

- select_type：查询的类型， simple、union等等
- table
- **type**：**查找到所需行的方式**
    - all：全表遍历
    - index：遍历索引树，不会回表
    - range：使用一个索引，检索给定范围
    - null：不用访问表或索引（例如从索引列中寻找最小值）
- possible_keys：粗略指出能使用哪个索引找到记录
- key：实际使用的键，如果未使用索引则为null
- ref
- extra：包含mysql查询时的信息
    - using where：全表搜索后用where过滤，需要添加合适索引
    - using temporary：创建了临时表存储结果，需要添加合适索引

# MVCC和Read view

MVCC（多版本并发控制）是一种实现数据库并发的抽象模型，用于维持数据的多个版本，使得读写操作不冲突。具体实现方式：隐式字段、undo log、read view

## 隐藏字段

InnoDB中每个聚集索引记录包含两个必要的隐藏列：

- trx_id：对该记录改动时的最新事务ID
- roll_pointer：指向修改前的信息

undo log会串成一个版本链

![img](https://img-blog.csdnimg.cn/a5b3145a6a4a4f798b700871de200a18.png)

## Read View属性

read view是数据库的一个快照，用于保存某个时刻的信息，核心是判断版本链中哪个版本是事务可见的。read view中包含4个主要内容：

- creator_trx_id：创建read view的事务ID（只在update等语句时分配）
- trx_ids：生成read view时，系统中活跃的事务ID列表
- up_limit_id：活跃事务中最小的ID
- low_limit_id ：生成read view时，系统中应该分配给下一个事务的ID，即已出现系统最大的事务ID+1

## Read View规则

在事务访问某个记录时，按如下步骤判断记录的某个版本是否可见：

- 该版本trx_id == creator_trx_id，说明该事务在访问自己修改过的记录，因此可以访问
- 该版本trx_id < up_limit_id，说明生成该版本事务read view创建前已经提交，因此可以访问
- 该版本trx_id >= low_limit_id，说明该版本事务在read view创建后才出现，因此该版本不能访问

# 数据库三范式

## 第一范式

数据表中的每一列（每个字段）都不可以再拆分

## 第二范式

第一范式的基础上，每列完全依赖于主键，而不能是依赖于主键的一部分

## 第三范式

第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键