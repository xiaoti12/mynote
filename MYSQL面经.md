# 索引原理

## 创建

mysql可以显式地为列创建索引，语句：`create index INDEXNAME on TABLE COLUMN1(, COLOMUN2...)`

通过使用索引，mysql可以直接定位到查询的行，而无需逐行扫描

## B树和B+树

### B树

B树是平衡二叉树引申而来的，属于多叉树。B树的要点：

- **节点**：为一个列表形式，包含关键字（*图中的数字*）以及指针。关键字递增排列，指针指向子节点。关键字左边指针指向的子树所有值均**小于**关键字，右边指针指向的子树所有值**大于**关键字。
- 子节点数：对于M阶B树，非叶节点的子节点范围为 $[\ \lceil m/2 \rceil,m\ ]$。
- 非叶结点的关键字树为k，则子节点数为k+1

B树的查找 $t$ 过程：

- 通过二分查找，从关键字列表中  $t$ 命中值，或者所属区间，取该区间的指针。
- 通过指针访问子节点，在子节点重复上面操作
- 直到命中节点 $t$、取节点所存放的数据；或者在叶子节点找不到该值

![clip_image002](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232634472-395289491.png)

### B+树

B+树在B树的基础上，做出了如下改进：

- 只在叶子节点保存数据，非叶子节点只保存关键字。叶子节点会保存所有关键字对应的数据
- 叶子节点的关键字会形成一个有序链表

因此，B+树的查询次数会更加稳定（都需要到叶子节点），B+树相比B树，非叶子节点不存储数据，因此可以存放更多关键字，使得树更矮，减少IO操作。

对于范围查询等遍历操作，B+树可以找到首个叶子节点后，通过链表进行遍历；而B树需要进行树的遍历。

> 对于每个16KB的页，当索引为8字节、指针为6字节时，一个节点（一页）大约可以存储1170个索引项；假设一行数据为1KB，则叶子节点可以存放16条数据  
>
> 因此，对于2层B+树，可以存放1170\*16≈18w行数据；对于3层B+树，可以存放1170\*1170\*16≈2200w行数据

![img](https://ask.qcloudimg.com/http-save/yehe-7619914/qd4miq0erv.png)

## InnoDB

mysql默认使用InnoDB作为引擎。InnoDB会将数据以**页**为单位，大小为16KB。一页可以分为4个块（每个块大小为4KB），这样当读取某个数据时，基于局部性原理，会将数据所在的页载入到内存。在后续通过B+树建立索引时，会以页为单位。

在InnoDB的B+树中，叶子节点通过双向链表连接。

![图片](https://cdn.xiaolincoding.com//mysql/other/dd076212a7637b9032c97a615c39dcd7.png)

# 索引场景

## 主键索引

从物理存储来说，索引可以分为：

- 聚集索引（主键索引、聚簇索引）：对于主键形成的索引
- 二级索引（辅助索引）：自行指定列构建的索引

两种索引均为B+树，聚集索引树叶子节点存放实际数据；二级索引树的叶子节点只存放对应**主键值**

- 如果从聚集索引 / 二级索引的一棵索引树上获取所需数据，则称为**索引覆盖**
- 如果需要去主键树进一步查找，则称为**回表**现象。

创建表时，InnoDB会按如下顺序选择列，生成聚集索引：

- 默认选择主键
- 选择第一个不包含NULL值的列
- 生成隐式自增ID列

## 索引失效

下面情况索引可能会失效：

- 左/左右模糊匹配：like %xx或like %xx%，因为B+树需要进行前缀匹配，因此like xx%仍能使用索引
- 对索引使用函数、表达式、隐式类型转换（可能）
- where中使用or时有一个条件列不是索引列
- 对于联合索引，查询不符合最左匹配

## 其他索引分类

按字段特性分类：

- 主键索引
- 唯一索引：建立在unique字段上的索引
- 普通索引
- 前缀索引：对字符串类型字段的前N个字符创建的索引，可以减少其占用的空间

按字段个数分类：

- 单列索引
- 联合索引：多个字段组合形成的索引，B+树中使用顺序组合字段作为key值进行查找

## 联合索引与最左匹配

使用联合索引时，会使用**最左前缀原则**。例如创建(a,b,c)索引时后，只有a、ab、ac、abc可以生效。因为联合字段优先排布最左字段，在**全局有序**的。而只有在左边字段确定的情况下，后面的字段才是有序的（**局部有序**）。

对于`(a, b, c)`的联合索引，考虑以下情况：

1. a=1、b=1：a和b都走索引
2. b=1：不走索引
3. a>1，b=1：a走索引，b不走索引（在范围内不是全局有序）
4. a=1、b>1、c=1：ab走索引，c不走索引

> 不过8.0之后加入了索引跳跃扫描，MySQL会对非最左查询字段进行优化
> 
> 当左边字段的值数量不大时，会对其进行展开，并union合并结果

# 慢查询优化

## 寻找原因

- explain查看执行过程，确认查询是否用到索引，索引是否合适
- 查看监控，确认慢查询发生时数据库负载状况

## 优化手段

- 设计**添加/修改索引**，避免全表查询。同时注意平衡索引的数量和维护成本
- 优化业务查询逻辑，**修改SQL语句**，比如修改连接方式、查询条件等等
- 当单个数据库节点负载过高时，可以考虑进行**水平扩容**，进行**读写分离**
- 对于一些耗时较长且对实时性要求不高的非核心业务查询，迁移到**离线集群**进行
- 如果发生了回表现象，可以考虑添加联合索引，形成**索引覆盖**

# InnoDB与MyISAM

InnoDB是MySQL在5.x之后默认使用的数据库引擎，此前为MyISAM，两者有以下区别：

- InnoDB支持事务；而MyISAM不支持
- InnoDB是聚集索引，数据保存在叶子节点上；MyISAM是非聚集索引，数据分散，索引保存数据指针
- InnoDB锁的最小粒度是行级锁（实现在索引上）；MyISAM是表锁，并发更困难
- InnoDB支持外键，MyISAM不支持

如果表中数据绝大多数都是读查询，可以考虑MyISAM；其他情况优先InnoDB

# 事务特性

事务由MYSQL引擎提供支持，5.5以前的默认引擎MyISAM不支持，新的InnoDB支持。

事务包含以下特征ACID：

- 原子性：事务的所有操作要么全完成，要么全不完成。通过**undo log**保证
- 一致性：操作前后，满足数据库一致性。通过其他三个特征保证
- 隔离性：多个事务操作相同数据时，不会相互干扰（*重点*）。通过**MVCC/锁机制**保证
- 持久性：事务结束后，对数据修改是永久的。通过**redo log**保证

## undo log

用于撤销回退的日志。在事务提交前，MYSQL会记录更新前的数据到undo log，例如：

- 执行 insert 时，记录主键值，回滚时删除
- 执行 delete 时，记录内容，回滚时插入
- 执行 update 时，记录旧值，回滚时更新

undo log的格式包括：事务ID trx_id、日志链表指针 roll_pointer，具体见MVCC章

## redo log

> 当有一条新的记录时，InnoDB会先更新内存中的缓存池（buffer pool），在适当的时候由后台线程将缓存池中的数据刷新到磁盘

redo log会记录某个数据页的修改操作，当事务提交时，先将redo log固化到磁盘。

写入redo log是追加式的顺序写入，而数据写入数据库是随机写，效率会高很多。而redo log写满后会从头开始。

## redo和undo区别

- redo log记录的是事务完成后的状态、更新之后的值
- undo log记录的是事务开始前的状态、更新之前的值
- 事务提交后崩溃，通过redo log恢复事务
- 事务提交前崩溃，通过undo log回滚事务

# 主从复制同步

为了读写分离，可以将主数据库设为写，从数据库设定为读，分散读写压力。当写请求锁表或锁行时，不影响读请求的执行。

## binlog

undo log和redo log由InnoDB生成，MySQL的server层还会生成binlog，适用于所有引擎。

binlog记录了数据库表结构变更和表数据修改的日志，通过追加写的方式，不断创建新的文件，保存全量日志，一般用于备份恢复、主从复制。有以下3种格式：

- STATEMENT：记录修改数据的SQL语句
- ROW：记录修改后的数据
- MIXED：混合使用两种模式

## 主从复制

大致可以分为三个步骤：

1. 主库接到从库的请求，后台线程将binlog发送给从库
2. 从库将得到的binlog，创建IO线程写到自己的**relay log**中
3. 从库创建SQL线程读取relay log日志，解析为具体操作或数据，实现主从一致

### 同步延迟

主库读取binlog的线程只有一个，当SQL执行时间较长、锁表锁库等情况时，就无法立即同步到从库；或者从库上执行较长时间的SQL。

解决方法：

- 关闭从库的binlog同步或不立即写入磁盘、提高性能和效率
- 提高从库硬件设备（因为只能单线程执行同步sql）
- 限制主库的写入/更新速度，QPS达到一定阈值后限流（来自实际案例）
- 业务上强制读主

## 复制模型

主要有这些复制模型 *可以理解为同步成功的响应机制*

- 同步复制：只有所有从库复制成功，才返回客户端结果，很少使用
- 异步复制：默认模型。主库马上返回客户端结果，异步复制binlog给从库
- 半同步复制：一部分从库复制成功后，返回客户端结果

## 两阶段提交

这种事务提交方式是为了保证redo log和binlog的一致性。可分为prepare阶段和commit阶段

- prepare：将事务ID写入redo log并持久化到磁盘，状态设为prepare
- commit：将事务ID写入binlog并持久化到磁盘，将redo log的状态设置为commit

当发生崩溃时，检查prepare状态的redo log的事务ID（XID）是否存在于binlog中，存在则提交，不存在则回滚

# 事务的并行与隔离

## 并行事务可能的问题

严重性从高到底

- 脏读：事务B读到了事务A *未提交事务修改的数据* ，如果事务A回滚，则B读到的是过期数据
- 不可重复读：事务读取同一数据时，前后数据不一样
- 幻读：事务查询同一条件的记录数量时，前后数量不一样

## SQL隔离级别

四种隔离级别如下，安全性从低到高，性能效率从高到低：

1. 读未提交：事务未提交时，变更能被看到
   - 可能发生：脏读、不可重复读、幻读
2. 读提交：事务提交后，变更能被看到。会在执行语句前生成read view。
   - 可能发生：不可重复读、幻读
3. 可重复读：事务执行时的数据和刚启动时的数据是一致的，**InnoDB默认隔离级别**。会在事务开启时生成read view。
   - 可能发生：幻读（可以很大程度避免）
4. 串行化：对记录加上读写锁
   - 不会发生并行问题

## MYSQL与幻读

mysql针对幻读现象的解决方法：

- 普通select语句，通过MVCC解决。简单来说，会在事务开始时创建一个数据快照。

- 当前读select for update语句（不创建快照），通过next-key lock（间隙锁+记录锁）解决。此时其他记录无法对next-key lock的范围内修改记录。

加锁的基本单位是next-key锁，一些情况会退化为记录锁或间隙锁

# 锁

## 锁的类型

- **全局锁**
  - 锁住整个数据库，处于只读状态
  - 适合全库备份
  - 如果引擎支持可重复读，可以备份前开启事务创建read view，这时可以避免锁
- **表锁**
  - 会影响并发性能，避免使用
  - 意向锁：快速判断表里是否有记录被加锁
- **行级锁**

### 行级锁

InnoDB支持的该级别，MyISAM引擎不支持。InnoDB默认创建行级锁，事务会对行数据进行锁定，直到当前事务结束。行级锁包含以下类型：

- 记录锁：锁住记录，分为共享锁/S锁（读读共享）和独占锁/X锁（读写互斥），也就是说只有加了S锁，可以再加S锁，其他均互斥
- 间隙锁：表示范围内的锁，解决可重复读下幻读问题，可以理解为开开区间的锁
- next-key锁：记录锁+间隙锁，可以理解为开闭区间的锁

### 表级锁

MyISAM引擎默认使用表级锁。InnoDB引擎下，全表备份、全表扫描、DDL表结构变更等操作时，会加上表锁。

## 加锁过程

普通的select不会加锁，属于快照读。如果想对select语句加锁，需要使用：

```sql
begin; -- 开启事务
select ... lock in share mode; -- 对读取的记录加共享锁(S型锁)
select ... for update; -- 对读取的记录加独占锁(X型锁)
commit; -- 释放锁
```

InnoDB自己实现了行锁，通过next-key锁，锁住记录和间隙。

update、delete、insert等语句会产生锁操作，阻塞其他读写操作。此时如果不是索引查询，就会引起**全表扫描**，会对每个记录加锁，退化成表锁。因此要先用explain语句检查

## explain

explain字段会返回的记录：

- select_type：查询的类型， simple、union等等
- table
- **type**：**查找到所需行的方式**
    - all：全表遍历
    - index：遍历索引树，不会回表
    - range：使用一个索引，检索给定范围
    - eq_ref：使用唯一索引，进行等值扫描
    - null：不用访问表或索引（例如从索引列中寻找最小值）
- possible_keys：粗略指出能使用哪个索引找到记录
- key：实际使用的键，如果未使用索引则为null
- ref
- extra：包含mysql查询时的信息
  - using where：全表搜索后用where过滤，需要添加合适索引
  - using temporary：创建了临时表存储结果，需要添加合适索引
  - using index：**覆盖索引**，直接从索引树上获取到所需列数据

# MVCC和Read view

MVCC（多版本并发控制）是一种实现数据库并发的抽象模型，用于维持数据的多个版本，使得读写操作不冲突。具体实现方式：隐式字段、undo log、read view

## 隐藏字段

InnoDB中每个聚集索引记录包含两个必要的隐藏列：

- trx_id：对该记录改动时的最新事务ID
- roll_pointer：指向修改前的信息

undo log会串成一个版本链

![img](https://img-blog.csdnimg.cn/a5b3145a6a4a4f798b700871de200a18.png)

## Read View属性

read view是数据库的一个快照，用于保存某个时刻的信息，核心是判断版本链中哪个版本是事务可见的。read view中包含4个主要内容：

- creator_trx_id：创建read view的事务ID（只在update等语句时分配）
- trx_ids：生成read view时，系统中活跃的事务ID列表
- up_limit_id：活跃事务中最小的ID
- low_limit_id ：生成read view时，系统中应该分配给下一个事务的ID，即已出现系统最大的事务ID+1

## Read View规则

在事务访问某个记录时，按如下步骤判断记录的某个版本是否可见：

- 该版本trx_id == creator_trx_id，说明该事务在访问自己修改过的记录，因此可以访问
- 该版本trx_id < up_limit_id，说明生成该版本事务在read view创建前已经提交，因此可以访问
- 该版本trx_id >= low_limit_id，说明该版本事务在read view创建后才出现，因此该版本不能访问

# 分库分表

## 垂直切分

将表按列字段分为多个表，可以按照列的密集程度，或者使用频率进行切分，分散到不同的库当中

## 水平切分（sharding）

将同一张表数据拆分为多个结构相同的表

### sharding策略

1. 查询切分：单独引入数据库节点，维护IDkey->db的映射关系
2. 范围切分：按照时间区间或ID区间划分
3. hash划分：`hash(key) mod DB_NUM`来确定位置，同时易于实现分库分表（如图）

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/52610d6d.png)



## 问题和解决

- 分布式事务问题：使用XA协议和两阶段提交，达成最终一致性
- 跨节点join查询：通过业务来实现join查询逻辑；字段冗余
- 全局主键冲突：使用UUID或者snowflake生成唯一ID

# 数据库三范式

## 第一范式

数据表中的每一列（每个字段）都不可以再拆分

例如“地址”这一属性，应该拆分成省份、城市、具体地址等字段

## 第二范式

第一范式的基础上，每列完全依赖于主键，而不能是依赖于主键的一部分（主要针对联合主键）

也就说，不同类型的数据最好放到不同的表里面

## 第三范式

第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键

确保数据的修改不会影响到不相关的数据
