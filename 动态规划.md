# 适用前提

当问题可以分解为若干小问题时，且满足下面两点时，可以使用动态规划

## 无后效性

- `f(i)`的转移方程确定后，就不用关心如何计算出`f(i)`
- 想要得到`f(i)`，只需要知道`f(i-1)`的值（只是例子），各自是如何计算出来的没有影响

即某阶段的状态确定后，就不受之后状态决策的影响

## 最优子结构

大问题的最优解可以分解为若干个小问题的最优解

还有一个特性为**重叠子问题**，这点将动态规划和分治算法做出一定的区分。动态规划的子问题是有重叠的，因此会将已经求解的子问题答案保存下来，后续直接查询。

# 通用解题

1. **定义状态**：包括最优解的定义、函数自变量
2. **初始状态**：基础子问题的起点
3. **转移方程**：原问题和子问题之间的关系，如何将原问题`f(i)`分解为子问题、如何将子问题的解组合为更上层的问题
4. **返回值**：停止迭代的地方

# 类型一：时间序列

给出一个序列，每一个/组元素只取决于**前一个**/组元素的状态。通常有一次“**做出某种策略的权利**”。

可以画出当前轮所有状态和前一轮所有状态的转移，然后写出转移方程。

一般需要遍历一遍序列，时间复杂度为O(N)。

![image-20230820203948769](C:\Users\xiaoti\AppData\Roaming\Typora\typora-user-images\image-20230820203948769.png)

状态`f(i)`可以表示不同的含义，例如以`f(i)`状态结尾的某个求解值（此时最终结果为`max(f)`或`min(f)`）；也可以是到`f(i)`为止的某个求解最值（此时最终结果为`f(N)`）

# 类型二：时间序列Ⅱ

给出一个序列，每一个元素取决于之前的某个元素，通常要使用sum、max、min等

一般对于某个元素，需要将之前的元素遍历一遍，时间复杂度为O(N^2)。

# 类型三：双序列

给出两个序列s和t，定义`dp[i][j]`，表示对s[i]和t[j]子问题的求解。将`dp[i][j]`往之前的状态转移：s往前（`dp[i-i][j]`）、t往前（`dp[i][j-1]`）、同时往前(`dp[i-1][j-1]`)

一般会依次遍历两个序列，时间复杂度为O(N^2)。

经典案例：最长公共子序列（LCS）和最短公共超序列（SCS）

## 最长公共子序列LCS

求解字符串s和字符串t的最长公共子序列（可以不连续）长度。状态转移：
$$
dp[i][j]=\begin{equation}
\left\{  
             \begin{array}{lr}  
            dp[i-1][j-1]+1, & s[i]=t[j]  \\  
             \max(dp[i-1][j],dp[i][j-1]), &  s[i]\ne t[j]  
             \end{array}  
\right.  
\end{equation}
$$
当s[i]和t[j]相等时，就在`dp[i-1][j-1]`的基础、即s[:i]和t[:j]这两个字符串的LCS上再加上相同的这个字符；如果不等时，这两个字符至少有一个不在LCS中，此时取两种情况的最大值就可以了

## 最短公共超序列SCS

求解同时以字符串s和字符串t为子序列的最短字符串长度。此时状态转移为：
$$
dp[i][j]=\begin{equation}
\left\{  
             \begin{array}{lr}  
            dp[i-1][j-1]+1, & s[i]=t[j]  \\  
             \min(dp[i-1][j],dp[i][j-1])+1, &  s[i]\ne t[j]  
             \end{array}  
\right.  
\end{equation}
$$
当s[i]和t[j]相等时，说明该字符串可以作为SCS的一员，在原有基础上加一；如果不等，则两个字符任意一个会添加到SCS的末尾，此时往前移动一位

# 类型四：区间型Ⅰ

给出一个序列s，要求**分割为K个连续区间**，计算区间的某个最优性质。

此时定义`dp[i][k]`表示为把序列前i个元素划分为k个区间，此时的最优解。对于`dp[i][k]`，可以拆分为`dp[j-1][k-1]`的子问题和`s[j,i]`这个区间，把结果merge起来。此时要满足`k<=i`（i个元素最多分k组）和`j-1>=k-1`（k-1组至少要j-1个元素）

![image-20230830162010631](C:\Users\xiaoti\AppData\Roaming\Typora\typora-user-images\image-20230830162010631.png)

一般存在i、k、j三层循环，时间复杂度为O(N^3)

# 类型五：区间型Ⅱ

只给出序列s，求针对s的最优解。对于index而言，没有*无后效性*（无法找出`dp[i]`仅依赖于`dp[i-n]`）。但大区间的最优解依赖于小区间的最优解。

因此可以定义`dp[i][j]`，表示求解s[i:j]子问题。一般存在起始点和区间长两层循环
