# Web认证跟踪技术
HTTP是一种无状态协议，每次建立新的连接时，不包含以前的信息。因此，服务器无法从连接上记录信息。
## session和cookie
session保存在服务器上，记录客户端的信息。服务端会分配一个唯一的sessionId，客户端请求时携带该字段，服务端查找对应信息。

cookie存在在客户端本地，可以记录用户状态、网页设置等等。可能被窃取、篡改，安全性不如session。

## JWT技术
JWT是session的改进，通过token进行认证
### 结构
JWT分为三个部分，通过"."拼接
- header：存放签名算法等信息，base64URL处理
- payload：存放实际需要传输的数据，base64URL处理
- signature：签名

其中header和payload默认不加密，因此不要放重要信息

### 认证方法
签名的生成方法：

`
HMAC( Base64(header)+Base64(payload), secret )
`

secret是服务端的私钥。服务端会生成JWT返回给客户端，客户端后续请求带上该token，服务端进行签名校验

### 安全措施
由于JWT模式下，服务器不保存会话状态，因此在token签发期间一直有效。期间JWT如果泄漏，导致获取token的人可以拿到用户信息。有以下两个方法：
- 尽量缩短有效期
- 通过HTTPS方式进行加密传输

此外，可以发放长期token，定期通过该token刷新得到新的JWT会话token

# 秒杀场景设计
## 前端
使用CDN缓存静态页面；秒杀界面加入验证码防止脚本；js文件在秒杀时间点亮按钮

## 缓存
- 针对热点数据，提前加载到缓存，进行**预热**
- 在服务器上使用本地缓存来减轻压力
- 缓存击穿、穿透、雪崩等问题见redis面经篇

## 库存
- 预扣库存：利用lua脚本等方式，redis查询余量、decr
- 回退库存：如果用户未支付，则incr操作进行回退

## 消息队列
将秒杀后下单的请求发送到mq异步处理，减轻服务器压力。

可以引入消息发送/处理表：
- 避免消息丢失：下单成功后回调接口，将消息设置为已发送；设置job定时重试待发送数据，重新发送
- 避免重复消费：消费消息时查询消息处理表，如果已存在则不消费；同时业务操作和更新处理表要在同事务中，保证原子操作

# 限流

# 设计模式
## 单例模式
适用场景：数据库/网络连接等只需要一个实例，全局日志记录器、配置管理器等等

确保一个类只有一个实例，提供全局访问点。

```go
package singleton
import (
    "sync"
)
// go方式的单例
type singleton struct {}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{}
    })
    return instance
}
```



## 工厂模式
适用场景：隐藏对象创建细节，将创建过程和具体实现解耦，有助于系统扩展

- 简单工厂：是使用一个类来实例化对象，根据传入的参数决定返回哪个类
- 工厂方法：定义工厂接口，对于类A，可以用对应的工厂类AFactory（实现工厂接口）返回A实例
- 抽象工厂：产品类可能有多维结构，抽象工厂类中声明一组创建所有抽象产品的方法。产品工厂类创建*产品接口*；产品类实现*产品接口*

![alt text](https://img2022.cnblogs.com/blog/1707576/202203/1707576-20220324190756963-1279534824.png)

## 建造者模式
创建类的设计模式，用灵活的方式创建复杂对象，适用于有很多构造参数的类。使用一个类`build()`方法，然后通过链式调用等方式设置对象参数，生成最终对象。

# TLS握手
## ~1.2握手过程

1. 客户端发送hello信息，包含客户端密码套件、随机数A
2. 服务端发送hello信息，包含选择的密码套件、随机数B
3. 服务端发送证书信息
4. 客户端验证服务端证书，生成随机数C，用服务端公钥进行加密，发送给服务端
5. 服务器使用私钥解密，得到随机数C。客户端、服务端使用约定的算法，用A、B、C生成相同密钥

## 1.3握手过程

TLS 1.3版本为了向下兼容，clinet hello的开头信息和之前一致，在extension里会表示支持1.3。

1. 客户端发送hello信息，包含随机数、密码套件、key_share（密钥组，包含密码算法的密钥参数）
2. 服务端选择密钥组，发送key_share（包含服务端参数）、证书、finished
3. 客户端检查证书，生成密钥，后续消息加密传输


## 证书链验证

假设存在根证书R->服务器证书A的链，那么对A签名时，根证书机构使用自己的私钥对证书A哈希值加密，得到签名。因此，客户端验证证书链的方式：
1. 用根证书公钥验证下一级证书A的公钥：计算证书A哈希值，使用根证书公钥对证书A签名进行解密，对比哈希值一致
2. 用下一级证书A公钥验证下下级证书B的公钥...
3. 最后验证服务端公钥有效


# 多线程
## 并发和并行
并发（concurrency）：同一个时间段内处理多个任务，任务交替运行

并行（parallelism）：同时执行多个任务，依赖于多(核)处理器

## 不同语言特性

- Go：基于goroutine轻量级线程，由runtime调度，线程之间可以通过channel通信
- Python：
    - `threading`模块：由于全局解释器锁GIL，多线程性能不好
    - `multiprocessing`模块：通过子进程来绕过GIL
    - `asyncio`模块：原生支持协程，适合处理I/O密集任务
- Java：通过`java.lang.Thread`类和`Runnable`接口来实现,直接映射到操作系统的原生线程